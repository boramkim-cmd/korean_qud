

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using UnityEngine;
using XRL;

namespace QudKRTranslation.Core
{
    public static class LocalizationManager
    {
        private static Dictionary<string, Dictionary<string, string>> _translationDB = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
        private static bool _isLoaded = false;
        private static string _modPath = null;

        public static void Initialize()
        {
            if (_isLoaded) return;
            LoadAllJsonFiles();
            _isLoaded = true;
        }

        public static void Reload()
        {
            _translationDB.Clear();
            _isLoaded = false;
            Initialize();
        }

        public static void LoadGlossary()
        {
            string modDir = GetModDirectory();
            if (string.IsNullOrEmpty(modDir))
            {
                Debug.LogError();
                return;
            }

            
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));

            
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));

            
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));
            LoadJsonFile(Path.Combine(modDir, ));

            
            
        }

        private static void LoadAllJsonFiles()
        {
            string locDir = Path.Combine(GetModDirectory(), );
            if (!Directory.Exists(locDir))
            {
                Debug.LogError($);
                return;
            }

            foreach (var file in Directory.GetFiles(locDir, ))
            {
                LoadJsonFile(file);
            }
        }

        private static string NormalizeKey(string key)
        {
            if (string.IsNullOrEmpty(key)) return key;
            
            
            string result = Regex.Replace(key, , m => $, RegexOptions.IgnoreCase);
            
            
            result = Regex.Replace(result, , );
            
            
            result = Regex.Replace(result, , );
            
            
            return result.Trim().ToLowerInvariant();
        }
        
        private static string GetModDirectory()
        {
            if (_modPath != null) return _modPath;

            try
            {
                var mod = ModManager.GetMod();
                if (mod != null && !string.IsNullOrEmpty(mod.Path))
                {
                    _modPath = mod.Path;
                    return _modPath;
                }
            }
            catch { }

            
            if (Application.platform == RuntimePlatform.OSXPlayer)
            {
                string homeDir = Environment.GetFolderPath(Environment.SpecialFolder.Personal);
                string modsRoot = Path.Combine(homeDir, );
                string target = Path.Combine(modsRoot, );
                if (Directory.Exists(target)) return target;
            }

            return ;
        }

        private static void LoadJsonFile(string path)
        {
            try
            {
                string json = File.ReadAllText(path);
                var data = RecursiveJsonParser.Parse(json);

                foreach (var categoryPair in data)
                {
                    string category = categoryPair.Key;
                    var terms = categoryPair.Value;

                    if (!_translationDB.ContainsKey(category))
                    {
                        _translationDB[category] = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    }

                    foreach (var termPair in terms)
                    {
                        _translationDB[category][termPair.Key] = termPair.Value;

                        
                        
                        string normalized = NormalizeKey(termPair.Key);
                        if (!string.IsNullOrEmpty(normalized) && !normalized.Equals(termPair.Key, StringComparison.OrdinalIgnoreCase))
                        {
                            if (!_translationDB[category].ContainsKey(normalized))
                            {
                                _translationDB[category][normalized] = termPair.Value;
                            }
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError($);
            }
        }

        
        
        

        public static Dictionary<string, string> GetCategory(string category)
        {
            if (!_isLoaded) Initialize();

            if (category.EndsWith())
            {
                return GetCategoryGroup(category.Substring(0, category.Length - 1));
            }

            if (_translationDB.TryGetValue(category, out var dict)) return dict;

            
            var subCats = _translationDB.Keys.Where(k => k.StartsWith(category + )).ToList();
            if (subCats.Count > 0) return GetCategoryGroup(category + );

            return null;
        }

        public static Dictionary<string, string> GetCategoryGroup(string prefix)
        {
            if (!_isLoaded) Initialize();
            var combined = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            var targets = _translationDB.Keys.Where(k => k.StartsWith(prefix, StringComparison.OrdinalIgnoreCase));

            foreach (var cat in targets)
            {
                foreach (var kv in _translationDB[cat])
                {
                    combined[kv.Key] = kv.Value;
                }
            }
            return combined.Count > 0 ? combined : null;
        }

        public static string GetTerm(string category, string key, string fallback = )
        {
            if (!_isLoaded) Initialize();

            if (string.IsNullOrEmpty(key)) return fallback;
            string normalizedKey = NormalizeKey(key);

            if (_translationDB.TryGetValue(category, out var dict))
            {
                
                if (dict.TryGetValue(key, out string val)) return val;
                
                if (dict.TryGetValue(normalizedKey, out val)) return val;
            }

            
            var subCats = _translationDB.Keys.Where(k => k.StartsWith(category + ));
            foreach (var cat in subCats)
            {
                var subDict = _translationDB[cat];
                if (subDict.TryGetValue(key, out string val)) return val;
                if (subDict.TryGetValue(normalizedKey, out val)) return val;
            }

            return string.IsNullOrEmpty(fallback) ? key : fallback;
        }

        public static bool TryGetAnyTerm(string key, out string result, params string[] categories)
        {
            if (!_isLoaded) Initialize();

            if (string.IsNullOrEmpty(key))
            {
                result = null;
                return false;
            }
            string normalizedKey = NormalizeKey(key);

            if (categories == null || categories.Length == 0)
            {
                foreach (var dict in _translationDB.Values)
                {
                    if (dict.TryGetValue(key, out result)) return true;
                    if (dict.TryGetValue(normalizedKey, out result)) return true;
                }
            }
            else
            {
                foreach (var cat in categories)
                {
                    if (_translationDB.TryGetValue(cat, out var dict))
                    {
                        if (dict.TryGetValue(key, out result)) return true;
                        if (dict.TryGetValue(normalizedKey, out result)) return true;
                    }

                    
                    string prefix = cat + ;
                    var subCats = _translationDB.Keys.Where(k => k.StartsWith(prefix));
                    foreach (var sc in subCats)
                    {
                        var subDict = _translationDB[sc];
                        if (subDict.TryGetValue(key, out result)) return true;
                        if (subDict.TryGetValue(normalizedKey, out result)) return true;
                    }
                }
            }

            result = null;
            return false;
        }

        public static bool HasTerm(string category, string key)
        {
            return GetTerm(category, key, null) != null;
        }
    }

    internal static class RecursiveJsonParser
    {
        public static Dictionary<string, Dictionary<string, string>> Parse(string json)
        {
            var result = new Dictionary<string, Dictionary<string, string>>(StringComparer.OrdinalIgnoreCase);
            if (string.IsNullOrEmpty(json)) return result;

            int index = 0;
            SkipWhitespace(json, ref index);

            if (index >= json.Length || json[index] != ) return result;
            index++; 

            while (index < json.Length)
            {
                SkipWhitespace(json, ref index);
                if (index >= json.Length || json[index] == ) break;

                
                string category = ParseString(json, ref index);
                SkipWhitespace(json, ref index);
                if (index < json.Length && json[index] == ) index++;
                SkipWhitespace(json, ref index);

                
                if (index < json.Length && json[index] == )
                {
                    var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
                    ParseObjectRecursive(json, ref index, dict);
                    result[category] = dict;
                }
                else
                {
                    
                    ParseValue(json, ref index);
                }

                SkipWhitespace(json, ref index);
                if (index < json.Length && json[index] == ) index++;
            }

            return result;
        }

        private static void ParseObjectRecursive(string json, ref int index, Dictionary<string, string> targetDict)
        {
            index++; 
            while (index < json.Length)
            {
                SkipWhitespace(json, ref index);
                if (index >= json.Length || json[index] == )
                {
                    index++;
                    return;
                }

                string key = ParseString(json, ref index);
                SkipWhitespace(json, ref index);
                if (index < json.Length && json[index] == ) index++;
                SkipWhitespace(json, ref index);

                if (index < json.Length)
                {
                    if (json[index] == )
                    {
                        
                        ParseObjectRecursive(json, ref index, targetDict);
                    }
                    else if (json[index] == )
                    {
                        
                        string val = ParseString(json, ref index);
                        targetDict[key] = val;
                    }
                    else
                    {
                        
                        ParseValue(json, ref index);
                    }
                }

                SkipWhitespace(json, ref index);
                if (index < json.Length && json[index] == ) index++;
            }
        }

        private static string ParseString(string json, ref int index)
        {
            System.Text.StringBuilder sb = new System.Text.StringBuilder();
            if (index < json.Length && json[index] == ) index++; 

            while (index < json.Length)
            {
                char c = json[index++];
                if (c == ) break;
                if (c == )
                {
                    if (index < json.Length)
                    {
                        char next = json[index++];
                        switch (next)
                        {
                            case : sb.Append(); break;
                            case : sb.Append(); break;
                            case : sb.Append(); break;
                            case : sb.Append(); break;
                            case : sb.Append(); break;
                            default: sb.Append(next); break;
                        }
                    }
                }
                else
                {
                    sb.Append(c);
                }
            }
            return sb.ToString();
        }

        private static void ParseValue(string json, ref int index)
        {
            SkipWhitespace(json, ref index);
            if (index >= json.Length) return;

            char c = json[index];
            if (c == )
            {
                
                int depth = 1;
                index++;
                while (index < json.Length && depth > 0)
                {
                    if (json[index] == ) depth++;
                    else if (json[index] == ) depth--;
                    index++;
                }
            }
            else if (c == )
            {
                
                int depth = 1;
                index++;
                while (index < json.Length && depth > 0)
                {
                    if (json[index] == ) depth++;
                    else if (json[index] == ) depth--;
                    index++;
                }
            }
            else if (c == )
            {
                ParseString(json, ref index);
            }
            else
            {
                
                while (index < json.Length && !IsDelimiter(json[index]))
                {
                    index++;
                }
            }
        }

        private static void SkipWhitespace(string json, ref int index)
        {
            while (index < json.Length && char.IsWhiteSpace(json[index]))
            {
                index++;
            }
        }

        private static bool IsDelimiter(char c)
        {
            return c ==  || c ==  || c ==  || char.IsWhiteSpace(c);
        }
    }
}
