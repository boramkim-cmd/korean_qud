# 절차적 생성 한글화 전략

**작성일시:** 2026-01-13 10:44  
**난이도:** ⭐⭐⭐⭐⭐ 최고 난이도

---

## 🎲 절차적 생성이란?

### 게임이 실시간으로 텍스트를 만드는 시스템

```
예시:
"=name= walked below the chrome arches"
→ 게임 실행 시: "Syuun walked below the chrome arches"
→ 매번 다른 이름
```

### 문제: 한글 조사

```
영어: "Syuun walked" (항상 같음)
한글: "수운이 걸었다" vs "철수가 걸었다" (조사 변경 필요)
```

---

## 📝 절차적 생성 파일들

### 1. HistorySpice.json (역사 생성)

```json
{
  "commonPhrases": {
    "leadIns": [
      "In the month of =month= of =year=, =name= walked..."
    ]
  }
}
```

### 2. Naming.xml (이름 생성)

```xml
<namestyle Name="Qudish">
  <prefix Name="fa" />
  <infix Name="ga" />
  <postfix Name="bas" />
</namestyle>
→ "Fagabas" (매번 다름)
```

### 3. Conversations.xml (동적 대화)

```xml
<text>Did you hear? <spice.gossip.leadIns.!random></text>
```

---

## 🔧 해결 방법 3가지

### 방법 1: 조사 태그 + Harmony 패치 (최선) ⭐⭐⭐⭐⭐

#### 원리

```
1. 번역 파일에 조사 태그 추가
   "=name=<josa_i_ga> 걸었다"

2. 게임 실행 시:
   "=name=" → "Syuun" (게임이 치환)
   "Syuun<josa_i_ga>" → "Syuun이" (Harmony 패치)

3. 최종 결과:
   "Syuun이 걸었다"
```

#### 구현

```csharp
// Harmony 패치로 변수 치환 후 조사 처리
[HarmonyPatch(typeof(HistorySystem), "ProcessText")]
public static void Postfix(ref string __result)
{
    // 1. 게임이 =name= → "Syuun" 치환
    // 2. 우리가 <josa_i_ga> → "이" 처리
    __result = JosaHandler.Process(__result);
}
```

#### 장점

- ✅ 모든 동적 텍스트 처리
- ✅ 자동화
- ✅ 유지보수 쉬움

#### 단점

- ❌ Harmony 패치 필요 (현재 컴파일 에러)
- ❌ 게임 API 정확히 알아야 함

---

### 방법 2: 조사 회피 번역 (차선) ⭐⭐⭐

#### 원리

```
조사가 필요 없는 문장으로 번역

영어: "=name= walked to the city"
나쁜 번역: "=name=이/가 도시로 걸어갔다" ❌
좋은 번역: "=name=, 도시로 향하다" ✅
```

#### 예시

```json
// 원본
"In =year=, =name= fought the girshlings"

// 조사 회피 번역
"=year=년, =name=의 거쉴링 전투"
"=year=년, =name= - 거쉴링과의 싸움"
```

#### 장점

- ✅ 즉시 적용 가능
- ✅ 기술적 문제 없음

#### 단점

- ❌ 자연스럽지 않음
- ❌ 원문과 뉘앙스 다름
- ❌ 모든 문장에 적용 불가

---

### 방법 3: 수동 패턴 매칭 (임시) ⭐⭐

#### 원리

```
자주 나오는 이름 패턴을 미리 처리

if (name.EndsWith("ㄴ")) → "이"
if (name.EndsWith("ㅏ")) → "가"
```

#### 구현

```csharp
public static string GuessJosa(string name)
{
    // 영어 이름 → 항상 "가"
    if (IsEnglish(name))
        return "가";

    // 한글 이름 → 받침 확인
    if (HasJongseong(name))
        return "이";
    else
        return "가";
}
```

#### 장점

- ✅ 간단한 구현

#### 단점

- ❌ 영어 이름 처리 어려움
- ❌ 100% 정확도 불가능

---

## 🎯 권장 전략 (단계별)

### Phase 1: 현재 (조사 회피)

```
HistorySpice.json, Naming.xml 등
→ 조사 없는 문장으로 번역
→ 즉시 적용 가능
```

### Phase 2: 중기 (게임 API 분석)

```
1. Assembly-CSharp.dll 디컴파일
2. 정확한 클래스 이름 찾기
3. Harmony 패치 수정
4. 조사 태그 시스템 완성
```

### Phase 3: 장기 (완전 자동화)

```
모든 동적 텍스트에 조사 태그
→ Harmony 패치로 자동 처리
→ 100% 자연스러운 한글
```

---

## 📋 실전 예시

### HistorySpice.json 번역

#### 원본

```json
{
  "commonPhrases": {
    "leadIns": [
      "In the month of =month= of =year=, =name= walked below the chrome arches"
    ]
  }
}
```

#### 방법 1: 조사 태그 (미래)

```json
{
  "commonPhrases": {
    "leadIns": [
      "=year=년 =month=월, =name=<josa_i_ga> 크롬 아치 아래를 걸었다"
    ]
  }
}
```

#### 방법 2: 조사 회피 (현재)

```json
{
  "commonPhrases": {
    "leadIns": [
      "=year=년 =month=월, =name=의 크롬 아치 행보"
    ]
  }
}
```

---

## 🔍 다음 단계

### 1. 게임 DLL 분석

```bash
# ILSpy로 Assembly-CSharp.dll 열기
~/Library/Application Support/Steam/.../Caves of Qud/CoQ_Data/Managed/

# 찾아야 할 클래스:
- ConversationNode
- HistorySystem
- QuestSystem
```

### 2. Harmony 패치 수정

```csharp
// 정확한 클래스 이름으로 수정
[HarmonyPatch(typeof(실제클래스이름), "실제메서드이름")]
```

### 3. 테스트

```
1. 간단한 패치부터 시작
2. 로그 확인
3. 점진적 확장
```

---

## 💡 현실적인 접근

### 지금 당장 (1-2주)

- ✅ 고정 텍스트 번역 (Quests, Conversations)
- ✅ 조사 회피 번역 (HistorySpice)

### 중기 (1-2개월)

- ⏳ 게임 API 분석
- ⏳ Harmony 패치 수정
- ⏳ 조사 태그 시스템

### 장기 (3-6개월)

- ⏳ 완전 자동화
- ⏳ 모든 절차적 생성 처리

---

**작성일:** 2026-01-13 10:44  
**권장:** Phase 1부터 시작 (조사 회피)
