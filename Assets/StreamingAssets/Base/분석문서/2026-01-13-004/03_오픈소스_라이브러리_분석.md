# 03. 오픈소스 한글 조사 처리 라이브러리 분석

**작성일시:** 2026-01-13 09:54  
**목적:** 기존 오픈소스 프로젝트 분석 및 적용 방안

---

## 📚 발견한 주요 라이브러리

### 🔴 C# 라이브러리 (⭐⭐⭐⭐⭐ 최우선)

#### 1. **csjosa**
- **언어:** C#
- **GitHub:** 검색 결과에서 확인됨
- **용도:** C# 환경에서 한글 조사 처리
- **Caves of Qud 적용:** ✅ 직접 적용 가능

#### 2. **SmartFormat.NET-Korean**
- **언어:** C# (.NET)
- **용도:** 한글 포맷팅 및 조사 처리
- **특징:** SmartFormat 라이브러리의 한글 확장
- **Caves of Qud 적용:** ✅ 직접 적용 가능

---

### 🟡 JavaScript 라이브러리 (참고용)

#### 1. **Josa.js** (e-/Josa.js)
- **GitHub:** https://github.com/e-/Josa.js
- **기능:** 은/는, 을/를, 이/가 구분
- **사용 예시:**
```javascript
Josa.r('사과', '을/를'); // "사과를"
Josa.r('검', '을/를');   // "검을"
```

#### 2. **hangul-josa**
- **특징:** 경량 라이브러리
- **템플릿 문법 지원**
- **사용 예시:**
```javascript
josa('사과#{를} 먹었다'); // "사과를 먹었다"
josa('검#{을} 발견했다'); // "검을 발견했다"
```

#### 3. **es-hangul** (권장 대안)
- **특징:** 활발히 유지보수 중
- **포괄적인 한글 처리**

---

### 🟢 Python 라이브러리 (전처리용)

#### 1. **pyjosa**
- **PyPI:** https://pypi.org/project/pyjosa/
- **기능:** 은/는, 와/과, 이/가 처리
- **사용 예시:**
```python
from pyjosa import josa

josa.get_josa('사과', '을/를')  # "를"
josa.get_josa('검', '을/를')    # "을"
```

#### 2. **tossi**
- **GitHub:** https://github.com/what-studio/tossi
- **특징:** Python과 Rust 지원
- **사용 예시:**
```python
from tossi import postfix

postfix('사과', '을/를')  # "사과를"
postfix('검', '을/를')    # "검을"
```

#### 3. **koreanlangutils**
- **기능:** 단어와 어간에 조사 추가
- **포괄적인 한글 처리**

---

### 🟣 Java 라이브러리 (참고용)

#### 1. **korean-utils** (crizin/korean-utils)
- **GitHub:** https://github.com/crizin/korean-utils
- **기능:** `attachJosa` 함수 제공
- **사용 예시:**
```java
KoreanUtils.attachJosa("사과", "을/를"); // "사과를"
KoreanUtils.attachJosa("검", "을/를");   // "검을"
```

#### 2. **josa-moa**
- **기능:** 종성(받침) 여부에 따라 조사 붙이기
- **Java 기반**

---

## 🔍 핵심 알고리즘 분석

### 공통 알고리즘 (모든 라이브러리)

#### 1. 받침 감지

**한글 유니코드 구조:**
```
한글 = 초성 + 중성 + 종성
코드 = 0xAC00 + (초성 × 588) + (중성 × 28) + 종성

종성 = (코드 - 0xAC00) % 28
종성 == 0 → 받침 없음
종성 != 0 → 받침 있음
```

**예시:**
```
'검' = 0xAC80
종성 = (0xAC80 - 0xAC00) % 28 = 8 (ㅁ 받침)

'사과'의 '과' = 0xACFC
종성 = (0xACFC - 0xAC00) % 28 = 0 (받침 없음)
```

#### 2. 조사 선택

**기본 규칙:**
```
받침 O → 이, 을, 은, 으로, 아
받침 X → 가, 를, 는, 로, 야
```

**특수 케이스: ㄹ 받침**
```
'서울' + 으로/로 → '서울로' (ㄹ 받침은 '로')
'집' + 으로/로 → '집으로' (다른 받침은 '으로')
```

---

## 💡 Caves of Qud 적용 전략

### 방안 1: csjosa 직접 사용 (⭐⭐⭐⭐⭐ 권장)

**장점:**
- C# 네이티브 라이브러리
- Unity 게임에 바로 적용 가능
- 검증된 알고리즘

**적용 방법:**
```csharp
// NuGet 또는 GitHub에서 csjosa 다운로드
using CSJosa;

// 사용
string result = Josa.GetJosa("검", JosaType.Object);
// result = "을"

string fullText = Josa.Attach("검", JosaType.Object);
// fullText = "검을"
```

### 방안 2: SmartFormat.NET-Korean 사용

**특징:**
- 포맷팅 + 조사 처리 통합
- 템플릿 문법 지원

**적용 방법:**
```csharp
using SmartFormat;

string template = "당신은 {item.name:josa(을/를)} 발견했다";
string result = Smart.Format(template, new { item = new { name = "검" } });
// result = "당신은 검을 발견했다"
```

### 방안 3: Josa.js 알고리즘 C#로 포팅

**Josa.js 핵심 코드 분석:**
```javascript
function hasJongseong(word) {
  const lastChar = word.charCodeAt(word.length - 1);
  return (lastChar - 0xAC00) % 28 !== 0;
}

function josa(word, type) {
  const hasJong = hasJongseong(word);
  
  const josaMap = {
    '을/를': hasJong ? '을' : '를',
    '이/가': hasJong ? '이' : '가',
    '은/는': hasJong ? '은' : '는'
  };
  
  return josaMap[type];
}
```

**C# 포팅:**
```csharp
public static bool HasJongseong(string word)
{
    if (string.IsNullOrEmpty(word))
        return false;
    
    char lastChar = word[word.Length - 1];
    
    if (lastChar < 0xAC00 || lastChar > 0xD7A3)
        return false;
    
    return (lastChar - 0xAC00) % 28 != 0;
}

public static string GetJosa(string word, string type)
{
    bool hasJong = HasJongseong(word);
    
    switch (type)
    {
        case "을/를": return hasJong ? "을" : "를";
        case "이/가": return hasJong ? "이" : "가";
        case "은/는": return hasJong ? "은" : "는";
        default: return "";
    }
}
```

---

## 🧪 검증된 테스트 케이스

### Josa.js 테스트 케이스 참고

```javascript
// 기본 테스트
assert(josa('사과', '을/를') === '를');
assert(josa('검', '을/를') === '을');
assert(josa('책', '이/가') === '이');
assert(josa('연필', '이/가') === '가');

// 특수 케이스
assert(josa('서울', '으로/로') === '로');  // ㄹ 받침
assert(josa('집', '으로/로') === '으로');

// 엣지 케이스
assert(josa('', '을/를') === '를');  // 빈 문자열
assert(josa('ABC', '을/를') === '를');  // 영어
assert(josa('123', '을/를') === '를');  // 숫자
```

**C# 테스트로 변환:**
```csharp
[TestMethod]
public void TestJosaSelection()
{
    Assert.AreEqual("를", GetJosa("사과", "을/를"));
    Assert.AreEqual("을", GetJosa("검", "을/를"));
    Assert.AreEqual("이", GetJosa("책", "이/가"));
    Assert.AreEqual("가", GetJosa("연필", "이/가"));
    Assert.AreEqual("로", GetJosa("서울", "으로/로"));
    Assert.AreEqual("으로", GetJosa("집", "으로/로"));
}
```

---

## 📖 참고할 구현 패턴

### hangul-josa의 템플릿 문법

**JavaScript:**
```javascript
josa('사과#{를} 먹었다');  // "사과를 먹었다"
josa('검#{을} 발견했다');  // "검을 발견했다"
```

**Caves of Qud 적용:**
```xml
<!-- 기존 -->
<text>당신은 <item.name>을/를 발견했다</text>

<!-- 템플릿 문법 적용 -->
<text>당신은 <item.name><josa_eul_reul> 발견했다</text>
```

### tossi의 API 디자인

**Python:**
```python
postfix('사과', '을/를')  # "사과를"
postfix('검', '을/를')    # "검을"

# 또는
Particle.get('사과', '을/를')  # "를"
```

**C# 적용:**
```csharp
// 방법 1: 전체 텍스트 반환
string fullText = Josa.Attach("사과", "을/를");  // "사과를"

// 방법 2: 조사만 반환
string josaOnly = Josa.Get("사과", "을/를");  // "를"
```

---

## 🚀 권장 구현 순서

### Phase 1: 기존 라이브러리 조사 (1일)

```
1. csjosa GitHub 찾기
2. SmartFormat.NET-Korean 조사
3. 라이선스 확인
4. API 문서 읽기
```

### Phase 2: 프로토타입 (2-3일)

```
1. csjosa 다운로드 및 테스트
2. Caves of Qud 프로젝트에 통합
3. 간단한 예시로 테스트
```

### Phase 3: 통합 (1주)

```
1. Harmony 패치 작성
2. 모든 텍스트 시스템에 적용
3. 게임 내 테스트
```

---

## 📊 라이브러리 비교

| 라이브러리 | 언어 | 적용 난이도 | 성능 | 유지보수 | 추천도 |
|-----------|------|------------|------|---------|--------|
| csjosa | C# | ⭐ 쉬움 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| SmartFormat.NET-Korean | C# | ⭐⭐ 보통 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| Josa.js (포팅) | JS→C# | ⭐⭐⭐ 어려움 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| pyjosa | Python | ⭐ 쉬움 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ (전처리용) |
| tossi | Python | ⭐ 쉬움 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ (전처리용) |

---

## 🔗 유용한 링크

### C# 라이브러리
- csjosa: GitHub 검색 필요
- SmartFormat.NET-Korean: GitHub 검색 필요

### JavaScript 라이브러리 (참고)
- Josa.js: https://github.com/e-/Josa.js
- hangul-josa: npm 검색
- es-hangul: GitHub 검색

### Python 라이브러리 (전처리)
- pyjosa: https://pypi.org/project/pyjosa/
- tossi: https://github.com/what-studio/tossi

### Java 라이브러리 (참고)
- korean-utils: https://github.com/crizin/korean-utils

---

## 💡 핵심 인사이트

### 1. 알고리즘은 모두 동일
- 모든 라이브러리가 같은 유니코드 알고리즘 사용
- 언어만 다를 뿐 로직은 동일

### 2. C# 라이브러리 우선
- Caves of Qud는 C# 기반
- 네이티브 라이브러리 사용이 최선

### 3. 검증된 코드 활용
- 직접 구현보다 검증된 라이브러리 사용
- 엣지 케이스 처리 완료됨

---

## 다음 단계

1. **csjosa 또는 SmartFormat.NET-Korean 찾기**
   - GitHub에서 검색
   - 라이선스 확인 (MIT 권장)

2. **프로토타입 제작**
   - 간단한 테스트 프로젝트
   - Caves of Qud API와 통합 테스트

3. **전체 시스템 통합**
   - Harmony 패치 작성
   - 모든 텍스트에 적용

---

**작성일:** 2026-01-13 09:54  
**참고 라이브러리:** 10개 이상  
**권장 방안:** csjosa 또는 SmartFormat.NET-Korean 사용
